<script>


    import {onMount, setContext} from 'svelte';
    import jsx from 'js-extension-ling';
    /**
     * I don't know why the commented line below is removed when I compile,
     * maybe it's rollup or a plugin that removes it?
     * Anyway, make sure you have this line un-commented in order for this plugin to work.
     */
    // import { fade } from 'svelte/transition';

    import { fade } from 'svelte/transition';
    import panda from "panda-headers";
    import Validator from "./modules/Validator";
    import GlobalProgressTracker from './modules/GlobalProgressTracker';
    import Translatee from "translatee";
    import DropZoneHandler from "js-dropzone-handler";
    import ChunkUploader from "chunk-uploader";
    import dragula from "dragula";
    import FileEditor from "./components/DefaultFileEditor.svelte";


    //----------------------------------------
    // EXPORT OPTIONS
    //----------------------------------------
    export let options = {};

    //----------------------------------------
    // SCRIPT VARIABLES
    //----------------------------------------
    options = jsx.extend(true, {
        /**
         * bool=false.
         * If true, this will add some bootstrap markup, mainly for buttons (things like btn btn-primary).
         * Note: you will still an external style sheet of yours to customize further, this is just to lay down the
         * basic html markup which is the first step to the bootstrapization of this widget.
         *
         */
        useBootstrap: false,
        /**
         * string=eng.
         *
         * The language used in the gui.
         *
         * Possible values are:
         * - eng
         * - fra
         *
         * To add your own, start with a copy/paste and adapt of the **lang/lang-fra.js** file.
         *
         *
         */
        lang: "eng",
        /**
         * int=1.
         * The maximum number of files that this widget will handle.
         * If the value is -1, then it can handle any number of files.
         *
         * If the value is 1, the widget will create an input (html element) that results in a scalar when the form is posted.
         * If the value is more than 1, the widget creates inputs of that results in an array when the form is posted.
         *
         */
        maxFile: 1,
        /**
         * string=dropzone-hover.
         * The css class added to the dropzone when the user's mouse is over the dropzone of the widget while he's dragging
         * a file from his OS.
         */
        dropzoneOverClass: "dropzone-hover",
        /**
         * array of strings=[].
         * An array of the urls to initialize the widget with.
         * Those urls will be loaded in the widget at startup.
         *
         */
        urls: [],
        /**
         * string=the_file.
         * The name attribute of the input html element(s) generated by this widget.
         */
        name: "the_file",
        /**
         * int=-1.
         * The maximum file size allowed for uploaded files.
         * You can specify human like values, such as 1.6k, 1.3M, etc...
         * The [converthumansizetobytes function](https://github.com/lingtalfi/js-extension-ling#converthumansizetobytes) is used under the hood.
         *
         * If -1, then any size is allowed.
         */
        maxFileSize: -1,
        /**
         * int=64.
         * The maximum length allowed for the filename of the uploaded files.
         */
        maxFileNameLength: 64,
        /**
         * array|string=null.
         *
         * The list of allowed file mime types for uploaded files.
         * null means every mime type is allowed.
         */
        mimeType: null,
        /**
         * array|string=null.
         *
         * The list of allowed file extensions for uploaded files.
         * null means every extension is allowed.
         */
        allowedFileExtension: null,
        /**
         * string=file.
         * The name of the uploaded file when sent to the server (via post).
         */
        uploadItemName: "file",
        /**
         * callback=the callback below.
         * When there is a problem with the server's response, this callback is called.
         * Note, it's called in addition to the default error handling system of this widget (i.e. it doesn't override
         * the widget's default behaviour).
         */
        onServerError: function (errorMessage) {
            console.log(errorMessage);
        },
        /**
         * callback=the callback below.
         *
         *
         * This callback returns whether the given url is external or internal.
         *
         * External means it's not recognized by the server (i.e. the server can't identify a file from that url).
         * Internal means it's recognized by the server.
         *
         * The behaviour of the server when an external urls is given depends on the server.
         * Some server will reject the request, some others will create a new internal url and return it to the client
         * so that the file can be handled correctly on the subsequent requests.
         *
         * Client side (this script), we have our own problems to solve.
         * The problem that we have which requires this callback occurs in the following situation:
         *
         *
         * update
         * ----------
         *
         * When the page starts, and an external url is given, the file item is displayed normally,
         * then when the user edits the file by opening the file editor dialog, when he clicks the update button,
         * that's where the problem begin, because our script sends the binary file only if the file has been modified
         * (image cropped, or new file dropped on the file editor dialog).
         * However if the user just changes the name of the file and click the update button, then our script
         * by default won't send the binary file, and so the server will be missing this information.
         *
         * In order for our script to send the binary file while preserving our optimized system,
         * we use this callback, which returns whether the given url is external or internal.
         *
         *
         * Note: you could make this work all the time by making this callback return true all the time,
         * but then the binary file would be sent on every update, that would defeat the purpose of our optimization.
         *
         * If you don't use external urls at all, then you don't need to worry about this callback at all.
         * If your application potentially uses external urls and you want your server to handle them (assuming it can),
         * then we recommend that you set this callback accordingly.
         *
         * By default, we return false, which means that there will be some potential problem if you try to send
         * an external url. But the intent of this choice is that you become aware of this problem and fix it to benefit
         * the optimized version of our script.
         *
         * If you're lazy and don't care of perfs, return true (not recommended).
         *
         *
         * Also, note that usually, if the server handles external urls, it will return an internal url,
         * so the isExternalUrl callback is just used the on the first update of an external url.
         *
         *
         *
         * delete
         * ----------
         * Also, the externalUrl is used with the delete action.
         * Since the server won't be able an external url, when we delete an external url's file, we simply
         * don't ask the confirmation from the server.
         *
         *
         */
        isExternalUrl: function (url) {
            return false;
        },
        /**
         * string=/upload.php
         * The url of the server.
         */
        serverUrl: "/upload.php",
        /**
         * map={}.
         * A map of extra parameters to pass (via post) with the server requests.
         */
        payload: {},
        /**
         * bool=false.
         * If true, the "upload files" button won't show up, and the files are automatically uploaded
         * as soon as the users adds them (either using the "add file" button, or by dropping them into the dropzone).
         */
        immediateUpload: false,
        /**
         * bool=false.
         * Whether to communicate with a virtual server like this one: https://github.com/lingtalfi/Light_UserData/blob/master/doc/pages/conception-notes.md
         * If true, the reset action of the [file manager protocol](https://github.com/lingtalfi/TheBar/blob/master/discussions/file-manager-protocol.md)
         * will be sent when the widget is first initialized, or when the wrapping form (if any) is reset.
         *
         * Also, when the wrapping form is submitted, this widget will trigger the "commit" action
         * on the server.
         *
         * Also, when accessing a file by its url, we add the v=1 flag, as recommended by the file manager protocol.
         *
         */
        useVirtualServer: false,

        /**
         * bool=false.
         * Whether to show the delete button on uploaded files.
         */
        useDelete: false,


        /**
         * bool=false.
         * Whether to use the keepOriginalUrl system of the [file manager protocol](https://github.com/lingtalfi/TheBar/blob/master/discussions/file-manager-protocol.md).
         * If true, when the file is uploaded, this widget also sends the keep_original flag to the server.
         * Also, it displays and handles the behaviour of a show original toggle button, so that the user can revert back to the original image if necessary.
         * Note: every time the user uploads a new file, the keep_original flag is resent to the server (so that the original image is the last image
         * uploaded by the user).
         */
        useKeepOriginalImage: false,

        /**
         * bool=false.
         * Whether to show the open file editor dialog button.
         */
        useFileEditor: false,
        /**
         * map={}.
         * The options for the file editor.
         */
        fileEditor: {

            //----------------------------------------
            // file
            //----------------------------------------
            /**
             * bool=false.
             * Whether the user can update the file extension.
             */
            fileExtensionCanBeUpdated: false,


            //----------------------------------------
            // directory
            //----------------------------------------
            /**
             * bool=false.
             * Whether to show the directory control.
             */
            useDirectory: false,

            /**
             * string="".
             * The default value of the directory control.
             */
            directory: "",
            /**
             *
             * bool=true.
             * Whether the directory can be updated.
             * It's generally a good idea to let the directory not fixed to a certain value,
             * as to sync the server with the gui,
             * as the server might change the directory defined by the user.
             */
            directoryCanBeUpdated: true,

            //----------------------------------------
            // visibility
            //----------------------------------------
            /**
             * bool=false.
             * Whether to show the visibility checkbox (private/public).
             */
            usePrivacy: false,

            //----------------------------------------
            // tags
            //----------------------------------------
            /**
             * bool=false.
             * Whether to show the tags control.
             */
            useTags: false,

            /**
             * bool=true.
             * Whether the user is allowed to create new tags.
             */
            allowCustomTags: true,
            /**
             * array=[].
             *
             * The array of tag names the user can choose from.
             *
             * Note: if allowCustomTags is true, the user can create his own tags,
             * otherwise his choice must be one of the available tags.
             *
             */
            availableTags: [],
            /**
             * int=5.
             * The number of tags the user can select/create.
             * This cannot be infinite.
             */
            nbTagsAllowed: 5,

            /**
             * bool=false.
             * Whether to show the image editor (if the file is an image).
             */
            useImageEditor: false,
        },


    }, options);

    let uFileCounter = 1;
    let testPartialSize = 0;
    let inputName = options.name;
    let isMultipleInput = false;
    if (options.maxFile > 1) {
        inputName += '[]';
        isMultipleInput = true;
    }

    let hiddenAddFileBtn;
    let elDropZone;
    let elTextItemsContainer;
    let elImageItemsContainer;


    if (false === jsx.arrayKeyExists(options.lang, FileUploader._langs)) {
        throw new Error("Lang not available: " + options.lang);
    }

    let dictionary = FileUploader._langs[options.lang];

    let translator = new Translatee();
    translator.setDefaultLang(options.lang);
    translator.addDictionary(options.lang, dictionary);
    let validator = new Validator();
    validator.setTranslator(translator);
    validator.init(options);
    let globalProgressTracker = new GlobalProgressTracker();
    let chunkUploader = null;


    //----------------------------------------
    // HTML THEME
    //----------------------------------------
    let styleBtnAddFile = 'btn-add-file';
    let styleBtnStartUpload = 'btn-start-upload';
    let styleBtnViewText = 'btn-view-text';
    let styleBtnViewImage = 'btn-view-image';
    if (true === options.useBootstrap) {
        styleBtnAddFile += ' btn btn-outline-dark btn-sm';
        styleBtnStartUpload += ' btn btn-outline-dark btn-sm';
        styleBtnViewText += ' btn btn-info btn-sm';
        styleBtnViewImage += ' btn btn-info btn-sm';
    }


    //----------------------------------------
    // STATE
    //----------------------------------------
    /**
     * each uFile:
     *
     * - id: string, the file id
     * - url: string=null, the file url. Note: if a file is dragged or selected via input, it doesn't have url yet.
     *
     * - directory: false|string.
     *      The default value depends on the configuration of this component (see the doc for more info).
     *      the base directory used for this file. This is used by some protocols.
     *      false means that the directory is not used at all (the user can't define one).
     *
     *
     * - name: string, the relative file path, from the base directory.
     *
     * - status: int=0
     *      The status of the file. Can be one of:
     *      - 0: initialized at startup (when the page refreshed), but the meta/blob are not ready (they need to be fetched from the server)
     *      - 1: same as 0, but the meta/blob are ready
     *      - 2: added by the user but not uploaded yet (url=null)
     *      - 3: added by the user and uploaded
     *
     *
     * - file: the js File object. This is not available with status=0.
     * - is_private: bool=false, whether the file is private or public
     * - is_user_data: bool=false
     *      experimental flag...
     *
     * - progress: the current percentage of the file loaded (for progress bar live display)
     * - tags: array of tags associated with this file
     * - keep_original: 0|1=0.
     *      A flag to indicate to the server whether to keep this file as an original source (to recall later).
     *      See more info in the properties description of this widget.
     *
     * - is_loading: bool=false.
     *      If true, a loader shall appear in the file item to indicate that an ajax action is pending in the background.
     *
     *
     */
    let uFiles = [];
    let editedUFile = null;
    let viewMode = 'image';
    let fileEditorIsOpen = false;
    let globalPercent = 0;
    let abortBtnVisible = false;
    let userErrors = [];
    let fileEditorErrors = [];
    let urls = options.urls;

    // global percent text transition vars
    let aIsVisible = true;
    let bIsVisible = false;

    $: totalSize = getTotalSize(uFiles);
    $: nbQueuedFiles = getNbQueuedFiles(uFiles);
    $: startUploadBtnEnabled = (false === options.immediateUpload && nbQueuedFiles > 0);


    //----------------------------------------
    // LIFE CYCLE
    //----------------------------------------
    onMount(async () => {


        //----------------------------------------
        // DROPZONE
        //----------------------------------------
        let dropZoneHandler = new DropZoneHandler({
            container: elDropZone,
            cssClass: options.dropzoneOverClass,
            onDrop: (files) => {
                addUserFiles(files);
            },
        });
        dropZoneHandler.start();


        //----------------------------------------
        // DRAGULA
        //----------------------------------------
        let drakeImg = dragula([elImageItemsContainer]);
        let drakeText = dragula([elTextItemsContainer]);
        drakeImg.on('drop', () => {
            let ids = getCurrentOrder(elImageItemsContainer);
            updateUFileOrder(ids);
        });


        drakeText.on('drop', () => {
            let ids = getCurrentOrder(elTextItemsContainer);
            updateUFileOrder(ids);
        });


        //----------------------------------------
        // VIRTUAL FILE SYSTEM
        //----------------------------------------
        if (true === options.useVirtualServer) {
            await reset();

            let dForm = elDropZone.closest('form');
            if (null !== dForm) {
                dForm.addEventListener('reset', async () => {
                    await reset();
                });
            }


        } else {
            resetUrls();
        }

    });

    //----------------------------------------
    // CONTEXT
    //----------------------------------------
    setContext("fileUploader", {
        onCloseFileEditorBtnClicked: closeFileEditor,
        onFileEditorFileDropped: updateUFileBinaryData,
        onFileEditorUpdated: updateUFileByFileEditor,
        fileEditorOptions: Object.assign(options.fileEditor, {
            dropzoneOverClass: options.dropzoneOverClass,
            useKeepOriginalImage: options.useKeepOriginalImage,
            useBootstrap: options.useBootstrap,
        }),
    });

    //----------------------------------------
    // FUNCTIONS
    //----------------------------------------
    function changeViewMode(mode) {
        viewMode = mode;
    }


    /**
     * Returns an uFile from the given js File.
     *
     * At its minimum, the uFile has the following properties:
     * - id
     * - url
     * - status
     * - directory
     * - name
     *
     */
    function createUFile(oFile, _options) {

        // null means do not display it at all
        let feo = options.fileEditor;
        let directory = '';


        if ('tags' in options) {
            while (options.tags.length > feo.nbTagsAllowed) {
                options.tags.pop();
            }
        }


        return jsx.extend({
            id: getNewFileId(),
            url: null,
            name: oFile.name,
            directory: feo.directory,
            file: oFile,
            status: 0,
            size: oFile.size,
            type: oFile.type,
            progress: 0,
            is_private: false,
            is_user_data: false,
            tags: [],
            keep_original: jsx.toInt(options.useKeepOriginalImage),
            is_loading: false,
        }, _options);
    }

    function getNewFileId() {
        return 'id' + uFileCounter++;
    }

    function addUFile(uFile) {
        uFiles = [...uFiles, uFile];
    }

    function updateUFile(uFile) {
        for (let i in uFiles) {
            let curUFile = uFiles[i];
            if (uFile.id === curUFile.id) {
                uFiles[i] = uFile;
                break;
            }
        }
    }


    function updateUFileBinaryData(uFile, oFile) {


        let res = validator.test(oFile);
        if (true === res) {
            uFile.file = oFile;
            uFile.size = oFile.size;
            uFile.type = oFile.type;
            uFile.name = oFile.name;
            uFile.status = 2;

            uFile.keep_original = jsx.toInt(options.useKeepOriginalImage);

            // special internal flag
            uFile.__preserveOriginalUrl = true;


            editedUFile = uFile;
            updateUFile(uFile);


            if (true === options.immediateUpload) {
                setTimeout(async function () {


                    try {

                        await uploadQueuedFiles({
                            action: "update",
                            url: uFile.url,
                            original_url: uFile.original_url,
                        });

                    } catch (e) {
                        /**
                         * It was annoying me, while debugging, when there was an upload error to be stuck on the loading gif image (because
                         * then the gui underneath disappear).
                         * So setting is_loading to false makes the loading gif image disappear, and allows me to continue uploading files,
                         * even if an error occurred.
                         **/
                        uFile.is_loading = false;
                        updateUFile(uFile);
                    }


                    let updatedEditedFile = _getUFileById(editedUFile.id);
                    editedUFile = updatedEditedFile;

                }, 1);
            }

        } else {
            addFileEditorError(res);
        }
    }


    async function updateUFileByFileEditor(uFile, postedData, flags) {


        let {cropped, dropped, original} = flags;

        uFile.is_loading = true;
        editedUFile = uFile;

        let fileHasChanged = (true === cropped || true === dropped || true === original);
        uFile.keep_original = jsx.toInt((true === dropped && false === original && false === cropped));

        let isExternalUrl = options.isExternalUrl(uFile.url);


        uFile = jsx.extend(uFile, postedData);

        let newUFile;
        if (true === isExternalUrl || true === fileHasChanged) {
            abortBtnVisible = true;
            newUFile = await uploadFile(uFile, {
                action: "update",
                url: uFile.url,
            }, {
                singleFile: true,
            });
            abortBtnVisible = false;
            refreshGlobalPercentText();
        } else {

            var data = jsx.extend({}, options.payload, {
                action: 'update',
                url: uFile.url,
                filename: uFile.name,
                directory: uFile.directory,
                tags: uFile.tags,
                is_private: jsx.toInt(uFile.is_private),
            });

            let jsonResponse = await callService(data);

            newUFile = await handleAddUpdateResponse(uFile, jsonResponse);

            /**
             * Preserving the old data since we didn't send the file (to save cpu work)
             */
            newUFile.file = uFile.file;
            newUFile.original_url = uFile.original_url;
            newUFile.type = uFile.type;
            newUFile.size = uFile.size;

        }


        if (false !== newUFile) {
            newUFile.is_loading = false;
            updateUFile(newUFile);
        }
    }


    async function removeUFile(id, serverCheck = true) {
        for (let i in uFiles) {
            let uFile = uFiles[i];
            if (id === uFile.id) {

                if (
                    true === serverCheck &&
                    false === options.isExternalUrl(uFile.url)
                ) {

                    uFile.is_loading = true;
                    uFiles = uFiles;


                    let response = await callService({
                        "action": "delete",
                        "url": uFile.url,
                    });
                    uFile.is_loading = false;
                    if (true === checkAcpResponse(response)) {
                        jsx.removeEntryByIndex(uFiles, i);
                        uFiles = uFiles;
                        break;
                    }
                } else {
                    jsx.removeEntryByIndex(uFiles, i);
                    uFiles = uFiles;
                    break;
                }

            }
        }
    }


    /**
     * Used at startup, to initialize the widget with some default urls.
     */
    function loadUrl(url) {


        let originalUrl = url;
        let fileName = url.split("/").pop();
        let fileId = getNewFileId();
        let uFile = {
            id: fileId,
            status: 0,
            url: url,
            name: fileName,
        };
        addUFile(uFile);

        if (true === options.useFileEditor) {
            url = jsx.url_merge_params(url, {
                "m": 1
            });
        }


        fetch(url).then(response => {
            if (response.ok) {
                response.blob().then(blob => {

                    /**
                     * create the uFile
                     */
                    let file = blobToFile(blob, fileName);


                    let moreHeaders = {};
                    if (true === options.useFileEditor) {
                        moreHeaders = panda.getPandaHeaders(response.headers);
                    }

                    let updatedUFile = createUFile(file, jsx.extend(moreHeaders, {
                        status: 1,
                        url: originalUrl,
                        id: uFile.id
                    }));
                    updateUFile(updatedUFile);
                });

            } else {
                addServerError(`An error occurred with the request for url ${url}. ` + response.status + ': ' + response.statusText);
            }
        });

    }

    function blobToFile(blob, name) {
        // https://stackoverflow.com/questions/27159179/how-to-convert-blob-to-file-in-javascript
        blob.lastModifiedDate = new Date();
        blob.name = name;
        return blob;
    }


    function getTotalSize(_uFiles) {
        let total = 0;
        _uFiles.forEach(uFile => {
            if (uFile.size) {
                total += uFile.size;
            }
        })
        return total;
    }


    function getNbQueuedFiles(_uFiles) {
        let total = 0;
        _uFiles.forEach(uFile => {
            if (2 === uFile.status) {
                total++;
            }
        })
        return total;
    }


    async function addUserFiles(files) {
        hiddenAddFileBtn.disabled = true;


        var numFiles = files.length;
        for (let i = 0; i < numFiles; i++) {

            let oFile = files[i];


            let res = validator.test(oFile);
            if (true === res) {
                let uFile = createUFile(oFile, {
                    status: 2,
                });
                addUFile(uFile);
                await applyFileRotation();
            } else {
                addUserError(res);
            }
        }

        if (true === options.immediateUpload) {
            setTimeout(function () {
                uploadQueuedFiles();
            }, 1);
        }


    }

    async function applyFileRotation() {
        if (-1 !== options.maxFile && uFiles.length > options.maxFile) {
            let nbFilesToRemove = uFiles.length - options.maxFile;
            while (nbFilesToRemove > 0) {
                nbFilesToRemove--;
                let uFile = uFiles[0];
                await removeUFile(uFile.id);
            }
        }

    }

    function onAddFileButtonClicked() {
        hiddenAddFileBtn.disabled = false;
        hiddenAddFileBtn.click();
    }


    function addUserError(err) {
        if (true === fileEditorIsOpen) {
            addFileEditorError(err);
        } else {
            userErrors = [...userErrors, err];
        }
    }

    function addFileEditorError(err) {
        fileEditorErrors = [...fileEditorErrors, err];
    }

    function removeErrorItem(e) {
        let el = e.target.closest(".error-item");
        if (null !== el) {
            el.remove();
        }
    }


    function getCurrentOrder(container, key = 'id') {
        let ret = [];
        let children = container.children;
        for (let child of children) {
            let attrName = "data-" + key;

            let id = child.getAttribute(attrName);
            if (id) {
                ret.push(id);
            } else {
                throw new Error("No element found with attribute " + attrName + ". This is a setup error, please fix it now.");
            }
        }

        return ret;
    }

    function updateUFileOrder(ids) {
        let newUFiles = [];
        let tmpUFiles = {};
        uFiles.forEach(uFile => {
            tmpUFiles[uFile.id] = uFile;
        });
        ids.forEach(id => {
            newUFiles.push(tmpUFiles[id]);
        });
        uFiles = newUFiles;
    }

    /**
     * Returns the [acp](https://github.com/lingtalfi/AjaxCommunicationProtocol) json response from the server.
     *
     */
    async function callService(payload, returnOriginalResponse = false) {

        payload = jsx.extend({}, options.payload, payload);

        var response = await jsx.post(options.serverUrl, payload).catch(reason => {
            var errMsg = "An error occurred with the request: " + reason;
            addServerError(errMsg);
        });
        if (true === response.ok) {
            if (true === returnOriginalResponse) {
                return response;
            }
            return await response.json().catch((e) => {
                addUserError(e.toString());
            });
        } else {
            addServerError("The server status code was " + response.status);
        }
    }

    async function reset() {


        var response = await callService({
            "action": "reset",
        });

        if (true === checkAcpResponse(response)) {
            resetUrls();
            return true;
        }
        return false;
    }


    function checkAcpResponse(response) {
        if (true === isSuccessfulResponse(response)) {
            return true;
        } else {
            addServerError(response.error);
            return false;
        }
    }

    function isSuccessfulResponse(jsonResponse) {
        if (jsx.isPlainObject(jsonResponse) && "type" in jsonResponse) {
            if ('success' === jsonResponse.type) {
                return true;
            }
        }
        return false;
    }


    function addServerError(err) {
        addUserError(err);
    }

    function abort() {
        if (null !== chunkUploader) {
            chunkUploader.abort();
            refreshGlobalPercentText();
        }
    }

    function resetUrls() {
        uFiles = [];
        let x = options.maxFile;
        urls.forEach(url => {
            if (x > 0) {
                loadUrl(url);
                x--;
            }
        });
    }

    async function uploadQueuedFiles(params = {}) {

        if (nbQueuedFiles > 0) {

            abortBtnVisible = true;

            globalProgressTracker.registerItems(uFiles);

            for (let [i, uFile] of uFiles.entries()) {

                let fileId = uFile.id;
                if (2 === uFile.status) {


                    uFile.is_loading = true;
                    uFiles = uFiles;

                    /**
                     * Note that the process will not go beyond this line if the user
                     * aborts the chunk upload.
                     */
                    let newUFile = await uploadFile(uFile, params);


                    if (false !== newUFile) {

                        newUFile.is_loading = false;
                        // update the file
                        uFiles[i] = newUFile;

                    } else {
                        removeUFile(fileId, false);
                    }
                }
            }

            abortBtnVisible = false;
            refreshGlobalPercentText();


        }

    }


    /**
     * Returns a promise that resolves to either:
     *
     * - uFile: the uFile corresponding to the successfully uploaded file, based on the given uFile
     * - false (bool): in case of error
     *
     */
    async function uploadFile(uFile, params = {}, _options = {}) {

        let useChunks = true;
        let jsonResponse = null;

        let singleFile = _options['singleFile'] || false;


        var data = jsx.extend({}, options.payload, {
            action: 'add',
            filename: uFile.name,
            directory: uFile.directory,
            tags: uFile.tags,
            is_private: jsx.toInt(uFile.is_private),
            keep_original: jsx.toInt(uFile.keep_original),
        }, params);


        // make sure you don't keep original for non images.
        if (false === jsx.mimeIsImage(uFile.type)) {
            data.keep_original = 0;
        }


        //----------------------------------------
        // USING CHUNKS (always a better idea)
        //----------------------------------------
        if (true === useChunks) {
            data.useChunks = 1;

            chunkUploader = new ChunkUploader({
                serverUrl: options.serverUrl,
                // chunkSize: 5 * 1024 * 1024,
                onChunkAborted: (start, end, isLastChunk) => {
                    abortUpload(uFile);
                },
                onChunkLoaded: (start, end, size, isLastChunk) => {
                    let percent = Math.round(end / size * 100, 2);
                    let id = uFile.id;
                    if (false === singleFile) {
                        globalProgressTracker.addProgress(id, percent);
                        globalPercent = globalProgressTracker.getPercent().toFixed(2);
                    } else {
                        globalPercent = percent;
                    }
                    updateUFileProgress(id, percent);
                },
                onChunkResponseReceived: async function (response) {
                    try {
                        jsonResponse = await response.json();
                        if (true === isSuccessfulResponse(jsonResponse)) {
                            return true;
                        } else {
                            return jsonResponse.error;
                        }
                    } catch (e) {
                        return e.toString();
                    }
                }
            });

            try {

                let response = await chunkUploader.sendByChunks(uFile.file, data, {
                    start: testPartialSize,
                });
                jsonResponse = await response.json();

            } catch (e) {
                jsonResponse = {
                    type: "error",
                    error: e,
                };
            }
        } else {
            //----------------------------------------
            // USING REGULAR UPLOAD
            //----------------------------------------
            data[options.uploadItemName] = uFile.file;
            let ajax = await jsx.uploadFileProgress(options.serverUrl, data, (e, percent, loaded, total) => {

                let id = uFile.id;
                globalProgressTracker.addProgress(id, percent);
                globalPercent = globalProgressTracker.getPercent().toFixed(2);
                updateUFileProgress(id, percent);

            });


            jsonResponse = JSON.parse(ajax.response);
        }

        return await handleAddUpdateResponse(uFile, jsonResponse);

    }

    async function handleAddUpdateResponse(uFile, jsonResponse) {
        if (true === checkAcpResponse(jsonResponse)) {

            // eliminate conflict of ajaxCommunicationProtocol.type (success|error) and our uFile.type (mime type)
            delete jsonResponse.type;


            if (true === uFile.__preserveOriginalUrl) {
                /**
                 * Needed this in the case of an update, using the virtual server, which didn't know the original url
                 * and returned original_url=null, but we want to keep the old original url (since the vfs doesn't
                 * know anything about whether the real original url exists or not).
                 */
                let originalUrl = uFile.original_url;
                uFile = jsx.extend(uFile, jsonResponse);
                uFile.original_url = originalUrl;
                delete uFile.__preserveOriginalUrl;
            } else {
                uFile = jsx.extend(uFile, jsonResponse);
            }


            if (true === jsx.mimeIsImage(uFile.type)) {
                /**
                 * We download the blob so that we can update the image (if ever the server changed it).
                 * Note that the server might not alter any other type of files, just images.
                 */
                let fileUrl = uFile.url;
                if (true === options.useVirtualServer) {
                    fileUrl += '&v=1';
                }

                let blob = await jsx.fetchBlob(fileUrl);
                uFile.file = blob;
                uFile.size = blob.size;
                uFile.type = blob.type;
            }


            /**
             * Note: the server's response will at least contain the url.
             * In the case of the fileManager protocol, it might have other properties as well, such
             * as:
             * - name (will override current uFile name)
             * - directory
             *
             */
            uFile.status = 3;

            if (null !== uFile.original_url) {

                if (true === options.useVirtualServer) {
                    uFile.original_url = jsx.url_merge_params(uFile.original_url, {v: 1});
                }
                uFile.keep_original = 0;
            }


            return uFile;
        }
        return false;
    }


    function updateUFileProgress(id, percent) {

        let bk = 2;

        for (let i in uFiles) {
            let uFile = uFiles[i];
            if (id === uFile.id) {
                uFile.progress = percent;
                uFiles = uFiles;
                bk--;
                if (0 === bk) {
                    break;
                }
            }

            if (null !== editedUFile && id === editedUFile.id) {
                editedUFile.progress = percent; // redundant? but seems to be required
                editedUFile = editedUFile;
                bk--;
                if (0 === bk) {
                    break;
                }
            }

        }
    }

    function abortUpload(uFile) {
        removeUFile(uFile.id)
    }

    function openFileEditor(id) {
        let uFile = _getUFileById(id);
        editedUFile = uFile;
        fileEditorIsOpen = true;
    }

    function closeFileEditor() {
        fileEditorIsOpen = false;
    }


    function refreshGlobalPercentText() {
        setTimeout(() => {
            if (true === aIsVisible) {
                aIsVisible = false;
                setTimeout(() => {
                    globalPercent = 0;
                    abortBtnVisible = false;
                    bIsVisible = true;
                }, 500);
            } else {
                bIsVisible = false;
                setTimeout(() => {
                    globalPercent = 0;
                    abortBtnVisible = false;
                    aIsVisible = true;
                }, 500);
            }
        }, 2000);
    }

    //----------------------------------------
    //
    //----------------------------------------
    function _getUFileById(id) {
        for (let uFile of uFiles) {
            if (id === uFile.id) {
                return uFile;
            }
        }
        throw new Error("uFile not found with id: " + id);
    }

    // function testLoader(id) {
    //     for (let i in uFiles) {
    //         let uFile = uFiles[i];
    //         if (id === uFile.id) {
    //             uFile.is_loading = true;
    //             uFiles = uFiles;
    //             break;
    //         }
    //     }
    // }


</script>


<div class="fileuploader-container">
    <div class="hidden-inputs" style="display: none">
        {#each uFiles as uFile (uFile.id)}
            <input type="text" readOnly name={inputName} value={uFile.url}/>
        {/each}
    </div>
    <div class="error-container">
        <div class="error-container-item">
            {#each userErrors as userError}
                <div class="error-item">
                    <span>{@html userError}</span>
                    <button on:click|preventDefault={removeErrorItem} class="btn-remove-error"><i
                            class="fas fa-times-circle btn-remove-error"></i></button>
                </div>
            {/each}
        </div>
    </div>
    <div class="header">
        <div class="left">{translator._("Select files")}</div>
        <div class="right">
            <button on:click|preventDefault={() => changeViewMode("text")}
                    class={styleBtnViewText}

            ><i
                    class="fas fa-list-ul btn-view-text"></i></button>
            <button on:click|preventDefault={() => changeViewMode("image")} class={styleBtnViewImage}><i
                    class="far fa-image btn-view-image"></i></button>
        </div>
    </div>
    <div class="dropzone" bind:this={elDropZone}>
        <div class="dropzone-text" class:visible={"text"===viewMode}>
            <div class="dropzone-text-header">
                <div class="cell-name">{translator._("Filename")}</div>
                <div class="cell-status">{translator._("Status")}</div>
                <div class="cell-size">{translator._("Size")}</div>
                <div class="cell-action"></div>
            </div>
            <div class="dropzone-text-container">
                <div class="dropzone-droptext">{translator._("Drag files here.")}</div>
                <ul class="fileuploader-item-container" bind:this={elTextItemsContainer}>
                    {#each uFiles as uFile (uFile.id)}

                        {#if 0 === uFile.status}
                            <li class="dropzone-text-item-container fileuploader-item ui-placeholder"
                                data-id="{uFile.id}">
                                <div class="cell-name">{uFile.name}</div>
                                <div class="cell-status">{translator._("Loading...")}</div>
                                <div class="cell-size">&nbsp</div>
                                <div class="cell-action gu-hide">&nbsp;</div>
                            </li>
                        {:else}
                            <li class="dropzone-text-item-container fileuploader-item" data-id="{uFile.id}">
                                <div class="cell-name">
                                    {uFile.name}
                                    {#if true === uFile.is_loading}
                                        <i class="fas fa-circle-notch fa-spin"></i>
                                    {/if}
                                </div>
                                <div class="cell-status">
                                    {#if uFile.status < 2}
                                        -
                                    {:else}
                                        {uFile.progress}%
                                    {/if}

                                </div>
                                <div class="cell-size">{jsx.humanSize(uFile.size)}</div>
                                <div class="cell-action gu-hide">
                                    {#if true === options.useFileEditor}
                                        <button on:click|preventDefault={() => openFileEditor(uFile.id)}
                                                class="btn-edit-file"><i
                                                class="btn-edit-file fas fa-edit"></i></button>
                                    {/if}
                                    {#if true === options.useDelete}
                                        <button on:click|preventDefault={() => removeUFile(uFile.id)}
                                                class="btn-remove-file"><i
                                                class="fas fa-minus-circle btn-remove-file"></i>
                                        </button>
                                    {/if}
                                </div>
                            </li>
                        {/if}
                    {/each}
                </ul>
            </div>
        </div>
        <div class="dropzone-image" class:visible={"image"===viewMode}>
            <div class="dropzone-droptext">{translator._("Drag files here.")}</div>
            <div class="filelist fileuploader-item-container" bind:this={elImageItemsContainer}>
                {#each uFiles as uFile (uFile.id)}

                    {#if 0 === uFile.status}
                        <div class="dropzone-image-item-container fileuploader-item"
                             data-id={uFile.id}>
                            <div class="cell-content">
                                <div class="cell-image">
                                    <span class="cell-image-img">
<!--                                        <i class="fas fa-circle-notch fa-spin loading-image"></i>-->
                                    </span>
                                </div>
                                <div class="cell-name">{uFile.name}</div>
                                <div class="cell-size"></div>
                            </div>
                            <div class="image-overlay">
                                <i class="fas fa-circle-notch fa-spin fa-2x"></i>
                            </div>
                        </div>
                    {:else}
                        <div class="dropzone-image-item-container fileuploader-item" data-id={uFile.id}>
                            <div class="cell-content">
                                <div class="cell-image">
                                    {#if true === jsx.mimeIsImage(uFile.type)}
                                        <img class="cell-image-img" src={URL.createObjectURL(uFile.file)}
                                             alt={uFile.name}/>
                                    {:else}
                                        <span class="cell-image-img"><i class="far fa-file"></i></span>
                                    {/if}
                                </div>
                                <div class="cell-name">{uFile.name}</div>
                                <div class="cell-size">{jsx.humanSize(uFile.size)}</div>
                            </div>
                            <div class="cell-action gu-hide">
                                {#if true === options.useFileEditor}
                                    <button on:click|preventDefault={() => openFileEditor(uFile.id)}
                                            class="btn-edit-file"><i
                                            class="btn-edit-file fas fa-edit"></i></button>
                                {/if}
                                {#if true === options.useDelete}
                                    <button on:click|preventDefault={() => removeUFile(uFile.id)}
                                            class="btn-remove-file"><i
                                            class="fas fa-minus-circle btn-remove-file"></i>
                                    </button>
                                {/if}
                            </div>
                            {#if true === uFile.is_loading}
                                <div class="image-overlay">
                                    <i class="fas fa-circle-notch fa-spin fa-2x"></i>
                                </div>
                            {/if}
                        </div>
                    {/if}
                {/each}

            </div>
        </div>
    </div>
    <div class="footer">
        <div class="left">
            <button on:click|preventDefault={onAddFileButtonClicked}
                    class={styleBtnAddFile}
            ><i
                    class="btn-add-file fas fa-plus-circle"></i> <span
                    class="btn-add-file">{
                0 === nbQueuedFiles ?
                    translator._("Add files") :
                    translator._n("x files queued", nbQueuedFiles)
            }

                </span>
            </button>
            {#if false === options.immediateUpload}
                <button on:click|preventDefault={uploadQueuedFiles}
                        class={styleBtnStartUpload}
                        disabled={!startUploadBtnEnabled}><i
                        class="btn-start-upload fas fa-arrow-circle-right"></i> <span
                        class="btn-start-upload">{translator._("Start upload")}</span></button>
            {/if}
        </div>
        <div class="right">
            <span class="footer-info"><span class="text-file">{translator._n("x files", uFiles.length)}</span></span>
            <span class="footer-info global-percent-upload">
                {#if true === aIsVisible}
                    <span transition:fade>{globalPercent}%</span>
                {/if}
                {#if true === bIsVisible}
                    <span transition:fade>{globalPercent}%</span>
                {/if}
            </span>
            <button on:click|preventDefault={abort} class="btn-abort-upload"
                    style="display: {abortBtnVisible?'inline-block':'none'}">
                <i
                        class="fas fa-ban btn-abort-upload"></i> {translator._("Abort")}
            </button>
            <span class="footer-info global-size">
                {jsx.humanSize(totalSize)}
            </span>
        </div>
    </div>
    <div class="hidden" style="display: none">
        <input bind:this={hiddenAddFileBtn} on:change={(e) => addUserFiles(e.target.files)}
               class="input-file"
               disabled
               type="file" name={inputName}
               multiple={isMultipleInput}
        />
    </div>


</div>


<FileEditor isOpen={fileEditorIsOpen} uFile={editedUFile} errors={fileEditorErrors}></FileEditor>


<style type="text/sass" lang="scss">

  $padding: 10px;
  $bgColor: #eee;
  $dropzoneTextHeaderHeight: 20px;
  $errorColor: #cd0a0a;
  $imgWidthHeight: 80px;


  .fileuploader-container {


    .hidden-inputs {

      input { // ease debugging
        display: block;
        width: 100%;
      }
    }

    position: relative;
    border: 1px solid #999;

    button {

      cursor: pointer;

      &.btn-start-upload:disabled {
        cursor: not-allowed;
      }

    }


    .error-container {
      color: #cd0a0a;

      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1;

      .error-container-item {

        position: relative;
        height: 100%;


        .error-item {

          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          border: 1px solid $errorColor;
          background: rgb(255, 232, 232);
          padding: 10px;
          background: linear-gradient(0deg, rgba(255, 232, 232, 1) 46%, rgba(255, 239, 239, 1) 56%, rgba(255, 239, 239, 1) 63%);


          button.btn-remove-error {

            position: absolute;
            top: 4px;
            right: 0px;

            background: transparent;

            border: none;
            color: $errorColor;

            cursor: pointer;

          }

        }

      }

    }

    .header {
      background: $bgColor;

      display: flex;
      padding: $padding;

      .right {

        margin-left: auto;

      }

    }

    @keyframes placeholderShimmer {
      0% {
        background-position: -1200px 0
      }
      100% {
        background-position: 1200px 0
      }
    }


    .ui-placeholder {
      position: static;
      overflow: hidden;
      animation: placeholderShimmer 2s linear;
      animation-iteration-count: infinite;
      background-color: #fff;
      background-image: linear-gradient(to right, rgba(0, 0, 0, 0.03) 0, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.03) 60%) !important;

      background-size: 1200px 100% !important;;

    }


    .dropzone {

      background: white;
      min-height: 150px;

      position: relative;

      &.dropzone-hover {
        background: #fafafa;

      }


      .dropzone-text, .dropzone-image {

        display: none;

        &.visible {

          display: block;

        }

      }

      .dropzone-text {

        .dropzone-text-header {

          display: flex;
          padding: 10px;


          background: rgb(209, 209, 209);
          background: linear-gradient(0deg, rgba(209, 209, 209, 1) 0%, rgba(227, 227, 227, 1) 100%);

        }

        .dropzone-text-item-container {

          display: flex;
          padding: 6px;
          margin: 0;

          position: relative;
          z-index: 1;

          background: rgb(228, 228, 228);
          background: linear-gradient(0deg, rgba(228, 228, 228, 1) 46%, rgba(238, 238, 238, 1) 56%);

        }


        .cell-status {

          margin-left: auto;
          width: 80px;

        }

        .cell-size {
          width: 70px;

          white-space: nowrap;

          overflow: hidden;

          text-overflow: ellipsis;

        }

        .cell-action {
          width: 30px;
        }


        .dropzone-text-container {

          position: absolute;
          top: 39px;
          left: 0;
          right: 0;
          bottom: 0;

          overflow-y: auto;

          font: normal 11px Verdana, sans-serif;

          ul {
            margin: 0;
            padding: 0;


            .cell-name {
              padding-left: 10px;

            }

            button.btn-remove-file, button.btn-edit-file {

              border: none;
              margin: 0;
              padding: 0;

              cursor: pointer;
              color: #919191;

            }

          }

        }

      }

      .dropzone-image {

        .filelist {

          display: flex;

          flex-wrap: wrap;

          position: absolute;
          top: 0px;
          left: 0;
          right: 0;
          bottom: 0;

          overflow-y: auto;


          .dropzone-image-item-container {

            position: relative;
            padding: 5px;
            background: #f0f0f0;
            margin: 5px;
            max-width: 80px;
            max-height: 120px;

            overflow: hidden;


            .cell-content {

              .cell-image {

                height: 80px;
                text-align: center;
                display: flex;
                justify-content: center;
                align-items: center;

                img {
                  max-height: 80px;
                  max-width: 80px;

                }

                i {
                  color: #c2c2c2;
                  font-size: 80px;

                  &.loading-image {
                    font-size: 50px;
                  }
                }

              }


              .cell-name {

                font: bold 11px Verdana, sans-serif;

              }

              .cell-size {

                font: normal 9px Verdana, sans-serif;

              }


              .cell-status {
                margin-top: 5px;
                font-size: 0.8em;
                text-align: center;

              }
            }


            .cell-action {

              position: absolute;
              top: 1px;
              right: 1px;

              button.btn-remove-file, button.btn-edit-file {

                border: none;
                margin: 0;
                padding: 0;

                cursor: pointer;
                color: #919191;

                background: transparent;

              }
            }


            .image-overlay {
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background: rgba(0, 0, 0, 0.2);
              display: flex;
              justify-content: center;
              align-items: center;

              i {
                color: white;
              }
            }

          }

        }

      }

      .dropzone-droptext {

        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        background: transparent;

        text-align: center;

        display: flex;

        justify-content: center;

        align-items: center;

        font: normal 11px Verdana, sans-serif;

      }

    }


    .footer {
      background: $bgColor;

      display: flex;
      padding: $padding;

      .right {

        margin-left: auto;

        font: bold 11px Verdana, sans-serif;
        color: #222;

        .footer-info:not(:last-child) {
          border-right: 1px solid #aaa;
          padding-right: 7px;
          margin-right: 7px;

        }

      }

    }

  }


  /*------------------------------------
  - DRAGULA
  ------------------------------------*/
  :global(.gu-mirror) {
    position: fixed !important;
    margin: 0 !important;
    z-index: 9999 !important;
    opacity: 0.8;
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=80)";
    filter: alpha(opacity=80);

    img {
      width: $imgWidthHeight;
      height: $imgWidthHeight;
    }
  }


  :global(.gu-unselectable) {
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;

    .gu-hide {
      display: none !important;
    }
  }


  :global(.gu-transit) {
    opacity: 0.2;
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=20)";
    filter: alpha(opacity=20);
  }

</style>