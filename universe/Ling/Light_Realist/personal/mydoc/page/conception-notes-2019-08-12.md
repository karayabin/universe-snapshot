Realist Conception notes
=================
2019-08-09



Again with the lists.
I've done that many times before, but I still want to redesign it, probably because I want everything to be perfect (i.e. as I exactly want).


So, my ambition here is to make a list that we'll be able to use in a front end, like a list of products for instance,
or a back end, like an list of users in the style of js datatable for instance.

In other words, I want a flexible list.



Basic nomenclature
------------

So what do all lists have in common?

- rows (arrays, each item of which having the same structure)
- some kind of widgets accompanying the list, like the pagination, or an ordering by date/pertinence widget, or a search input, those kind of things


Having said that, I realize that my perfect composition is done. 
I mean, to render a list, I'll create some renderer, nothing special there,
and to get the rows, we'll get them from where we want (an manually written array, a database, whatever...).

So that's my perfect conception of a list right there, and I have nothing to add.




So what is this planet all about?
------------------

However there is an area where I want to give more focus: the parameters of the list (ordering, sorting, filtering),
although the list "brain" might inject some default values, those parameters usually can be modified by the user via the gui,
and so in the case of rows generated by a database, I want to focus on that (gray for now) area of how the params are 
transmitted from the gui to the list, and if there are some tools that we can use to make the implementation of a list quick and trivial (since 
lists are one of the most common widgets out there).


So let me think a sec...

        

Note: browsing through my planets, I noticed those that might help:

- [gui admin table](https://github.com/lingtalfi/GuiAdminTable) a rendering example 
- [the hybrid list](https://github.com/lingtalfi/HybridList), which I believe was my last try in this area
- [SqlQuery](https://github.com/lingtalfi/SqlQuery), a tool to create sql query using oop techniques (so we can share the instance across plugins)

Seing the hybrid list, I kind of like the idea of having parameters shaping a sql request.
But it looks a bit complicated, I need to dig more to see if there are any superfluous things I can remove.


Give me another second...


Well reviewing my notes, I figured out that the hybrid list system allows to handle the ordering, sorting and filtering
using two systems in parallel: php and sql. The reason said to justify this was the following:  

QUOTE:
    - Unfortunately, sometimes things get more dynamical. For instance, the sort might depend on a data that is not/cannot be stored in the database. Same for filters.
    When this case occur, we need to rely on php to manually do the filtering, sorting [...]


So I believe I said that because I was creating the [Ekom module](https://github.com/KamilleModules/Ekom), and I
had to order the products by popularity, but the popularity field was not in the database, I had to compute it manually
based on the number of comments and their rating.

That was some time ago, but now I believe that with a proper database structure, we should be able to handle everything using (my)sql only.

Note: maybe I'm too optimist here, because I remember having REALLY complex mysql queries, and so if I still used the Hybrid list,
was it because of a deadline problem or was I facing a real wall? I don't know, but ok let's take the bet that it's possible.


And so, all this php side of the hybrid list seems now superfluous to me, and I intend to fix it in this repository.

However, I spotted the [SqlQuery](https://github.com/lingtalfi/SqlQuery), which is used by the hybrid list.

I remember now one of the main problem I had when creating ekom: the filters on the left of the product list, there were a lot
of different filters, depending on the product type being displayed (I even remember building the filter list dynamically,
based on which product types were actually displayed).

And so the need to build the query based on multiple parameters became real.

From my experience, using SqlQuery to handle this was ok, it did the job, but I believe I want to test something new.
With SqlQuery, the sql query kind of lost its soul, it was kind of scattered, and I want to try to have it back re-united, if I can.

In fact, thinking about that, I found out what I want to focus on in this repo.



What will we be focusing on?
------------

Two things for now.

You know how the widgets accompanying a list can be scattered over a page.
On the other hand, server side, to execute a request we need all the parameters at once.

So my first idea will be to focus on a js tool which will basically gather all those scattered bits wherever they are on the page, 
and converts them into one single united http (post or get) request.

Some kind of protocol about how to specify list parameters in a gui if you will.

The second thing I want to focus on is this collaboratively created sql request: how? 

Do we use SqlQuery? Probably not. Rather, I want to focus on a tool that would allow us to keep the sql unity, while still
allowing its parametrization. 


So to recap:

- js tool to gather all list params on the page and post one http request
- php tool to parametrize sql queries without loosing its unity (i.e. without having the bits of the query scattered everywhere)


I want to start with the php tool, the js tool being less challenging.

 

A collaboratively created parametrized sql query
---------------------

### TEST BabyYaml file (aka thinking out loud):


my_complex_query:
    base: select * from blabla 
    joins:
        color: inner join color blabla       // note the color id re-used in the where statement, it's some kind of "pack":
                                             // if the color tag is activated, it will be activated in both the join and the where section...
        popularity: inner join ffff.dd on ...                                   
    where:
        color: color in :colors
        price_less_than: price <= :price
        price_more_than: price >= :price     // note the js tool must exclude one or the other?
        // or
        price...:
            less_than: price <= :price 
            more_than: price <= :price
    group_by:
        color: (I don't know yet, long time didn't write a sql query, but the tag idea remains)
    having:
        color: (I don't know yet, long time didn't write a sql query, but the tag idea remains)                
    order: 
        date: order by date desc
    limit:  
        page: $page      // a variable bought by the gui
        length: 10       // a constant chosen by the dev        
        

So as we can see above, this is my new implementation idea for a collaboratively created sql query.

The benefit of this technique is that the author creates the sql query and has it under the eyes (it's not scattered via oop).
Also, it seems to give more control, as we permit certain things by listing everything that's allowed, and implicitly this means
that everything else is not allowed (I don't remember if we could do that in hybrid list, but anyway it's seems simpler here).

So, I don't know yet if that will work, real concrete cases will tell, but it looks promising to me.

At least I can just create the tool, and see how concrete plugins will use that.


This is of course just an overview. I'll be creating another file for more implementation details later.

For now let me rest a bit.


2019-08-12

Ok, so back on this project. Actually you know what, I will not create another file for implementation details, because
I woke up this morning with the implementation scheme in my idea, and it's quite trivial, however it seems so trivial that
I suspect it might not work in practise, but let's give it a try because that's all I've got for now.

So I thought that maybe a request would be sometimes very complex and would require more than a simple map translation (translating
parameters to a parametrized sql request written in advance): sometimes it would maybe require some more application logic, more dynamism.
So I decided to go with an interface that would execute a request based on an identifier (and params), and the interface would then bind
the request identifier to the appropriate system (either the simple parametrized system, or if necessary a more oop based system, where everything is possible).

But that's not all, a lot of requests (probably the most majority of them in fact) would be common requests, like select all from a given table. No joins, no tricks, a simple request
that M. potato could write out of his mind in a snap of finger. Well, I don't want to spend an identifier for that, given that if I do, I would have to generate every possible
request handled by the app, and associate an identifier to each of them. Not only would it be time consuming, but also memory is a resource to spend wisely and this can be avoided.

So I figured out I would use a tool, and this tool would have two methods:

- executeRequest ( request, params )
- executeRequestById { requestId, params )


I like the use of this tool for two reasons:

- first if the application uses ONLY THIS TOOL for all those requests, we could easily bind some listeners to that tool to get things like stats about the requests executed,
and, if the application REALLY ONLY USE this system, we could even go for a hook system, where certain request would trigger some cascade actions.
However, this would only work with request identifiers (not the free system). I mean it could work with the free system, but at the cost of some extra work.
Hey, I've got an idea. Instead of executeRequest method, maybe we could have this:

- tool->common()->insert( table, params )
- tool->common()->delete( table, params )
- tool->common()->update( table, params )
- tool->common()->select( table, params )


So that we know the table and the type of action executed, and so maybe now the idea of a hook system might become more realistic.
Not sure because I don't have a concrete hook system example in mind right now.

So I guess I will just switch to the implementation for now, my sketch above seems plausible to me as a usable hook system. Hopefully I didn't forget crucial
details. 



Actually you know what, all this conception above looks like a light service implementation to me.
In the realist planet, I just want to focus on the parametrized request, nothing more.

Oh, and I forgot to say: we will be using SqlQuery at the heart of the parametrized request system, because
it would make thinks easier wouldn't it?



Realist conception
====================

So now after all this brainstorming, here are the conception notes related to this planet only.
Realist is a translation tool (i.e. an adaptor), it translates a request identifier and some parameters into 
a SqlQuery object. That's all.

And so I should rename this planet (realist is more the idea of the whole service): ParametrizedSqlQuery.
Or actually I'll do the opposite, I will move this part to another planet, and this planet will be the 
real Realist planet.










Personal notes
----------

I like the fact that this tool centralizes the requests in files in a given folder.
Makes it easier to grasp what's happening.

I anticipated that it would be possible for instance for an admin plugin to say: 
"If the user doesn't have the xxx right, then don't display the password field for this table", for instance.

This would be done just by adding fields to the array, and babyYaml makes it really easy to spot what happens in a glance.
Whereas an oop based solution (like I had before with ekom) with all things scattered in oop classes, it was not so clear
what's going on, plus, if you come6 months later on the project, although cmd+F is your friend, it's quite hard to find
the right class(es) that you're looking for. It feels like finding the needle in a haystack, literally.

And so this centralized ability saves us a lot of time (at least that's what I believe now, but there is no implementation at the moment,
we will see). 



Also, I just thought that if we want to implement a cache system, we could first put the heaviest requests (i.e. not all
requests are heavy) in this file, so that they have an id we can refer to.

With this id, we can bind a cache strategy, simply by adding a cache property, which is an array with whatever properties we need.
And so yes, hooking all kinds of services becomes easy (we have an overview of what happens), is centralized (well organized)
and so some time will definitely be saved.











