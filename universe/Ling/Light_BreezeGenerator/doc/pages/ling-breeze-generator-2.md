Ling Breeze Generator 2 
=================
2020-05-20 -> 2020-07-27




Overview
------------
2020-05-20 -> 2020-05-21

The **LingBreezeGenerator2** will generate classes for you, saving you a lot of typing.


It's an upgrade compared to the former **LingBreezeGenerator**.
 
The main improved points are:

- the organization of classes has been redesigned (see the generated structure below), so that it's simpler, safer and more flexible.
- the configuration has been simplified 

 


Those generated classes are ORM classes (which I designed), and so they are derived from the tables of a database.

The **LingBreezeGenerator** can either analyze the tables directly from an actual database connection,
or it can create tables from a mysql dump, such as one generated by MySqlWorkBench and/or phpMyAdmin.   

There are 2 different types of generated files:

- custom 
- generated 
 
The custom files are the concrete files used by the api.
They extend their generated counterpart.

Also, they are meant to be edited by the human developer and therefore the generator will create those files **only** if they don't exist,
so that the developer can safely add manual content in it, without fearing that this content will be accidentally overwritten by the generator.
 


Generated structure
-----------------
2020-05-20


Example of a generated structure in the file system:


- /path/to/api/:
    - Generated
        - Classes/:
            - FruitBaseApi.php 
            - AppleApi.php 
            - BananaApi.php
            - CherryApi.php
        - Interfaces/:
            - AppleApiInterface.php 
            - BananaApiInterface.php
            - CherryApiInterface.php
        - FruitFactory.php 
    
    - Custom
        - Classes/
            - CustomFruitBaseApi.php 
            - CustomAppleApi.php 
            - CustomBananaApi.php
            - CustomCherryApi.php        
            
        - Interfaces/
            - CustomAppleApiInterface.php 
            - CustomBananaApiInterface.php
            - CustomCherryApiInterface.php

        - CustomFruitFactory.php 



The entry point of the api is the **CustomFruitFactory** class, which extends the generated **FruitFactory** class.
The factory class gives access to all other classes.

So for instance the **getAppleApi** method (of the factory class) returns an instance of the **CustomAppleApi** class,
which extends the generated **AppleApi** class.

Then the **AppleApi** extends the **CustomFruitBaseApi** class which in turn extends the generated **FruitBaseApi**.
This part is a bit confusing but at least it allows the developer to extend the base api (which contain common methods
shared by all generated classes) via the **CustomFruitBaseApi** class.

In other words, we have those inheritance relationships:

- **CustomAppleApi** <- **AppleApi** <- **CustomFruitBaseApi** <- **FruitBaseApi** 
- **CustomBananaApi** <- **BananaApi** <- **CustomFruitBaseApi** <- **FruitBaseApi** 
- **CustomCherryApi** <- **CherryApi** <- **CustomFruitBaseApi** <- **FruitBaseApi** 


And in terms of interfaces:

- **CustomAppleApi** implements **CustomAppleApiInterface**
- **AppleApi** implements **AppleApiInterface**

So basically the **CustomAppleApi** has the methods from both interfaces (**CustomAppleApiInterface** and **AppleApiInterface**)
The same schema applies for all fruits.


And lastly, we have **CustomAppleApiInterface** extends **AppleApiInterface** (same for all fruits), so that it eases code auto-completion
of methods in the IDE.




Generated methods
----------
2020-05-21 -> 2020-07-27


For a regular table name **tag**:

- id: primary key (auto-increment)
- name: unique index



the generated methods will look like this:


- fetch
- fetchAll
- insertTag
- insertTags
- getTagById
- getTagByName
- getTag
- getTags
- getTagsColumn
- getTagsColumns
- getTagsKey2Value
- getTagIdByName
- getTagsByResourceId
- getTagsByResourceResourceIdentifier
- getTagIdsByResourceId
- getTagIdsByResourceResourceIdentifier
- getTagNamesByResourceId
- getTagNamesByResourceResourceIdentifier
- getAllIds
- updateTagById
- updateTagByName
- delete
- deleteTagById
- deleteTagByName
- deleteTagByIds
- deleteTagByNames

    
    
Although the **has** tables (table which have a many-to-many relationship) are handled a bit differently,
the generated methods are approximately the same.    






How to use it?
-----------
2020-02-03 -> 2020-05-21

First create a configuration file (see the config section below for more details), and register it via our service.
In the following example, we registered it with the identifier **luda**.


If you're inside a light page, you can do this directly.

```php
az($container->get("breeze_generator")->generate("luda"));
```


Otherwise, you can do something like this:

```php
<?php

require_once "init.inc.php";

$f = "/komin/jin_site_demo/config/data/Light_UserData/Light_BreezeGenerator/luda.byml"; // your config file

$container->get("breeze_generator")
    ->addConfigurationEntryByFile("luda", $f) 
    ->generate("luda");
```






Configuration
-------------
2020-05-21

The configuration is an array with some properties described below.

It's convenient to store them in a [babyYaml](https://github.com/lingtalfi/BabyYaml) file like this:



```yaml

class: Ling\Light_BreezeGenerator\Generator\LingBreezeGenerator2
conf:

    source:

#        Use either file, database or tables as the source
        file: /komin/jin_site_demo/universe/Ling/Light_UserData/assets/fixtures/recreate-structure.sql
#        database: true
#        tables: []


#        Used to filter the tables to parse
        prefix: luda


        prefixes:
            - luda
            - lud


    target:
        dir: ${app_dir}/universe/Ling/Light_UserData/Api2
        namespace: Ling\Light_UserData\Api2
        apiName: LightUserData

    options:
        dev: false


```


- **class**: string, mandatory.
    The generator class to use. Just use **LingBreezeGenerator2** (as in the example), 
    or you could use the older version **LingBreezeGenerator** instead if you wanted to use the older generator.

- **conf**: array, mandatory.
    Contains the configuration for the generator defined with the class property.
    
    - **source**: array, mandatory.
        Defines the source/input of the generator.
        Basically, the source defines which tables of your database to parse.
        
        You can choose between 3 different types of sources: file, database or tables: 
        
        - **file**: string, optional.
            The .sql file to parse. The generator will parse that file and extract the tables from it.
            The file should use the **CREATE TABLE** syntax (so for instance .sql files generated with
            phpMyAdmin or MysqlWorkBench are ok).
            
        - **database**: bool=true, optional.
            The generator reads the tables from an existing database.
            
        - **tables**: array, optional.
            The tables to parse.
            
        - **prefix**: string, optional.
            Note: I didn't test the generator without using a prefix so, it might have some bugs if you don't use a prefix.
            
            The prefix will be used to filter the tables to parse.
            So, we first define the tables using a source method (file, database, or tables), and then the **prefix**
            property filters those tables (which the generator will parse).
            
            So for instance if the prefix is **luda**, all tables which name doesn't start with **luda_** will be filtered out.
            
        - **prefixes**: array, optional.
            It's a code that I ported from the old **LingBreezeGenerator** (the previous version of this generator).
            
            I'm not sure what it does exactly (i.e. I don't need it now), I believe it's supposed to strip the prefix
            from related table names (i.e. if your tables are using foreign keys or things like that) to generate 
            the class names without those prefix.
            
            If you're not sure, just add one entry in it which is the same value as the **prefix** property.

    - **target**: array, mandatory.
        Defines where to put the generated classes.
        
        - **dir**: string, mandatory.
            The destination directory. All generated classes will be put in that directory.
            
        - **namespace**: string, mandatory.
            The base namespace to use inside every generated class.
            
        - **apiName**: string, mandatory.
            The name of your api. If we take the fruit example from the **generated structure** section earlier in this document,
            then the name would be **Fruit**.
                
    - **options**: array, optional.
        Some options to control the behaviour of the generator.
        
        - **dev**: bool=false, optional.
            If true, the custom classes will be overwritten. Never do that, unless you're extending the generator class itself.
                     
            
            
            
Suggestion for plugin authors, the getFactory method
============
2020-06-08


My suggestion for plugin authors is that their main service should provide a **getFactory** method, which returns the factory for their api.

If every plugin author does that, then it becomes easy for the end developer to access pretty much any database related method of any plugin, it just
requires a knowledge of the database design to start interacting with a plugin.            
        
               
   


