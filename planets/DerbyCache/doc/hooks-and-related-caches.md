Hooks and related caches
================================
2017-11-18


Yesterday, when inventing DerbyCache, I was too tired to mention the related caches, which is one
of the most important constraint we need to be aware of when designing a cache system (I believe).

When you build a cache for an object A, it can also involves related caches.

For instance:

- object A uses the 3 following objects (all cached too)
    - B
    - C: which in turns also needs the two following objects (all cachable too):
        - C2
        - C3
    - D
    
    
So we need to be aware of that chain of related objects (A, B, C, C2, C3, D).
If we know that chain, then later we decide what happens when we delete A:

- do we delete all related caches (probably the most common case)
- we could also decide to only delete A, and leave alone all the "children"
- we could do more fancy things based on conditions, like delete C2 and C3, but not B, C, and D, you get the idea


So again, we need to be aware of that chain.



Hooks
-----------

Hooks is one first step towards implementation of knowing related caches.

We put hooks into the get method of the DerbyCache.
The get method is very simple: either it returns the cache from the callback, or from the "store".

Hooks in the get method are:

- onCacheStart
- onCacheHit
- onCacheCreate
- onCacheEnd


On every call, only three hooks out of four will be executed, because either onCacheHit xOR onCacheCreate
can be executed.


We can imagine the benefits of hooks implementation in our dev life:

- we can monitor every cache call in our app (knowledge is a weapon)
- we can collect the related caches automatically, by marking the onCacheStart and onCacheEnd events, and 
        collecting every call in-between
        
        
Figures
-------------
A figure is the name of an important object in our app, an object that we want to cache.
In my Ekom module for instance, I have the following important objects that I want to cache:

- product box          
- various category arrays, like category_menu
                  

By defining a list of figures, we can decide to collect cache only if the cache is a figure.



General structure example
------------------------------

- my_cache_dir/
    - cache
        - ...all the cache items generated by our app via Derby
    - figures
        - ...same naming as the corresponding cache item, but containing the list of related caches.
                Only the figures are there.
            

 
 
A word about naming convention, again
---------------------------------------
Note that you can name your cache item's components using the principle of "prefix" in mind.
For instance, if you name all elements of your menu:

- Ekom/category_menu_12
- Ekom/category_menu_13
- Ekom/category_menu_14
- ...


Then later, when building your "rebuild" command, you will be able to delete all category menus easily.

```php
DerbyCache::create()->deleteByPrefix("Ekom/category_menu_")
```

That's one you want to spot right now, and not after when everything is too late.









